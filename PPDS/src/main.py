import re
import traceback

import util
import shutil
import os.path
from glob import glob

from PPDS.src.PreprocessorDataClass import PreprocessorDataClass
from parse import PPDSParseError, parse_args_string
import template_factory

from config import get_config

conf = get_config()


# TODO: must allow this to be in another directory -> not needed, bc the dir must
# be on the include header path anyways
SOURCE_REX = r'\s+\#include\s+\"PPDS_SOURCE_(\w+?)\.h\"'

# TODO: I noticed too late that file-objects save their filename.
# this makes a lot of code here unnecessary. refactor some time? maybe


class PPDSAbstractTargetHeaderFile:
    def __init__(self, filename):

        self.filename = filename
        # f is always either an open file or None
        self.f = open(os.path.join(ppds_target_header_dir, self.filename), "w")
        self.write_opening_message()

    # TODO: better opening messages
    def write_opening_message(self):
        if self.f is None:
            raise ValueError("File has been closed already")
        self.f.write(
            """/* AUTOGENERATED, DO NOT EDIT. */
/* This file was created by PPDS. */
"""
        )

    def write(self, s: str):
        if self.f is None:
            raise ValueError("Cannot write to file that is not open")
        self.f.write(s)

    def reopen(self):
        if self.f is not None:
            raise ValueError("Trying to open file that is already open")
        self.f = open(os.path.join(ppds_target_header_dir, self.filename), "a")

    def close(self):
        if self.f is None:
            raise ValueError("File is already closed")
        self.f.close()
        self.f = None

    def __str__(self):

        return str((self.f, self.filename))

    # I keep doing this though it is not good
    def __repr__(self):
        return str(self)


class PPDSDefTargetHeaderFile(PPDSAbstractTargetHeaderFile):
    def write_opening_message(self):

        super().write_opening_message()
        self.f.write(
            """
/* This file contains definitions generated by DECLARE statements.*/
\n
"""
        )


class PPDSUndefTargetHeaderFile(PPDSAbstractTargetHeaderFile):
    def write_opening_message(self):

        super().write_opening_message()
        self.f.write(
            """
        /*This file removes definitions as cleanup.*/
        \n
        """
        )


# Top file is always open, can write directly to top
class PPDSTargetFileStack:
    def __init__(self):

        self.ls = []

    def __len__(self):

        return len(self.ls)

    def push(self, file):

        # sanity check
        if not isinstance(file, PPDSAbstractTargetHeaderFile):
            raise ValueError(str(file) + " is not valid in file-stack")

        # close the previous file
        if not self.is_empty():
            self.ls[-1].close()

        self.ls.append(file)

    def is_empty(self):

        return len(self.ls) == 0

    def pop(self):

        ret = self.ls.pop()

        if not self.is_empty():
            self.ls[-1].reopen()

        return ret

    def write_to_top(self, s: str):

        if self.is_empty():
            raise ValueError("Cannot write to empty stack")

        self.ls[-1].write(s)

    def __str__(self):

        return str(self.ls)


def_rex = re.compile(r'\#include\s+"PPDS_DEF_(\w+)\.h"')
undef_rex = re.compile(r'\#include\s+"PPDS_UNDEF_(\w+)\.h"')

# instead of being handed a single ppds_data_class,
# it should be passed a list of regex that are considered to be constructors
# then, scan the file and whenever a constructor is seen, the corresponding action is taken.
def handle_code(ppds_data_class, cleaned_c_source, filename):

    defstack = PPDSTargetFileStack()
    undefstack = PPDSTargetFileStack()

    # the important lines are: include def, include undef and declare
    for line_no, line in enumerate(cleaned_c_source.splitlines()):

        try:
            assert len(defstack) == len(undefstack)

            # is it a definition-target-header?
            m = re.match(def_rex, line)
            if m:
                defstack.push(PPDSDefTargetHeaderFile(f"PPDS_DEF_{m.group(1)}.h"))
                undefstack.push(
                    PPDSDefTargetHeaderFile(f"PPDS_UNDEF_{m.group(1)}.h")
                )
                print("new def header")
                print(defstack)
                continue

            m = re.match(undef_rex, line)
            if m:
                def_file = defstack.pop()
                undef_file = undefstack.pop()
                md = re.match(r"PPDS_DEF_(\w+)\.h", def_file.filename)
                mu = re.match(r"PPDS_UNDEF_(\w+)\.h", undef_file.filename)
                assert md
                assert mu
                assert mu.group(1) == md.group(1)
                if mu.group(1) != m.group(1):
                    raise PPDSParseError("closing wrong scope")

                print("new undef header")
                print(defstack)
                continue



            # todo: hier vielleicht das Zeug in die python-files einfuegen?
            # also die python-snippets? Nein, eigentlich haben nur Funktionen ein snippet
            # (nein, jede PPDSDataClass hat eigene python-snippets, die aber ohne die Funktion keinen Sinn ergeben haben ein)
            # was ist mit den anderen c-snippets?
            #
            # die ppds_data_class hat alle infos, um alle snippets zu generieren.
            # hier in der main sollte dann immer das richtige angefordert werden und in das richtige file geschrieben werden

            # die bekannten patterns sollten aus den ppds-source-files kommen und die Konstruktoren darstellen
            # alle bekannten patterns zusammen sollten

            for constr_rex in ppds_data_class.constructor_list:
                m = re.match(constr_rex, line)
                if m:
                    raw_args = m.group(1)
                    argdict = ppds_data_class.parse_args(raw_args)
                    declare_site = f"file: {filename}, line {line_no}"

                    extradef = ppds_data_class.render_def(argdict, declare_site)
                    extraundef = ppds_data_class.render_undef(argdict, declare_site)

                    defstack.write_to_top(extradef)
                    undefstack.write_to_top(extraundef)

        except PPDSParseError as e:
            print(
                f"""
ERROR parsing PPDS-annotations in file {filename} line {line_no}:
{line.strip()}
{e.reason}

{e.detail}
            """
            )  # TODO: this somehow catches too many exceptions
            # raise
            exit(1)
        except Exception as e:
            print(f"""
An unknown problem occured during parsing of your source-file. See stacktrace below.            
This could be due to a error in your code or in PPDS.
Even if your code is wrong, PPDS should be able to give you a hint on what is wrong with it, so please file a bug report.
Problematic code is in file {filename}  line {line_no}:
{line}
""")
            traceback.print_tb(e.__traceback__)

    assert len(defstack) == len(undefstack)
    if len(defstack) > 0:
        # this should not be a valueerror but a proper message
        raise ValueError(f"unclosed definition-headers: {defstack}")


# conf-file over cmdline for most things
ppds_source_header_dir = conf.source_header_loc
ppds_target_header_dir = conf.target_header_loc
# conf.pygen_target_loc
# ppds_source_header_loc = conf.pygen_usables_loc


if conf.pygen_target_loc is not None:
    shutil.copytree(
        src=conf.pygen_usables_loc, dst=conf.pygen_target_loc, dirs_exist_ok=True
    )

files = set()
for s in conf.search_paths:
    if not isinstance(s, str):
        print("search paths must be strings, but in config file found: {s}")
        exit(1)
    matches = glob(s, recursive=True)
    print("matches: ", matches)
    files = files.union(set(glob(s)))

print("ppds preparing files: ", files)



# the approach is to get the PPDS_SOURCE-files used by each file,
# turn that source-file into the PPDSDataClass,
# then let that dataclass handle the whole file
# this is not the most efficient way to do it but it works
for filename in files:

    with open(filename, "r") as f:
        # preserves line numbers
        code = util.remove_comments(f.read())

    source_names = re.findall(SOURCE_REX, code)
    source_strings = []
    pp_dataclasses = [] # all pp_dataclasses found in this specific file
    for name in source_names:
        try:
            source_filename = f"PPDS_SOURCE_{name}.h"
            with open(os.path.join(ppds_source_header_dir, source_filename)) as f:
                source_string = f.read()
            source_strings.append(source_string)
            pp_dataclasses.append(PreprocessorDataClass(name, source_string))
        except PPDSParseError as e:
            print(
                f"""
ERROR related to file {source_filename} :

{e.reason}

{e.detail}
                """
            )
            exit(1)

    for ppc in pp_dataclasses:
        handle_code(ppc, code, filename)
    print(pp_dataclasses)
