import re
import sys
import util
import jinja2
import json
import os.path

from parse import PPDSParseError, parse_args_string
import template_factory




#TODO: must allow this to be in another directory -> not needed, bc the dir must
#be on the include header path anyways
SOURCE_REX = r'\s+\#include\s+\"PPDS_SOURCE_(\w+?)\.h\"'

# TODO: I noticed too late that file-objects save their filename.
# this makes a lot of code here unnecessary. refactor some time? maybe

class PPDSAbstractTargetHeaderFile():

    def __init__(self, filename):

        self.filename = filename
        # f is always either an open file or None
        self.f = open(os.path.join(ppds_target_header_dir, self.filename), "w")
        self.write_opening_message()


    #TODO: better opening messages
    def write_opening_message(self):
        if self.f is None:
            raise ValueError("File has been closed already")
        self.f.write(
"""/* AUTOGENERATED, DO NOT EDIT. */
/* This file was created by PPDS. */
"""
        )

    def write(self, s : str):
        if self.f is None:
            raise ValueError("Cannot write to file that is not open")
        self.f.write(s)

    def reopen(self):
        if self.f is not None:
            raise ValueError("Trying to open file that is already open")
        self.f = open(os.path.join(ppds_target_header_dir, self.filename), "a")

    def close(self):
        if self.f is None:
            raise ValueError("File is already closed")
        self.f.close()
        self.f = None

    def __str__(self):

        return str((self.f, self.filename))

    # I keep doing this though it is not good
    def __repr__(self):
        return str(self)

class PPDSDefTargetHeaderFile(PPDSAbstractTargetHeaderFile):

    def write_opening_message(self):

        super().write_opening_message()
        self.f.write(
"""
/* This file contains definitions generated by DECLARE statements.*/
\n
"""
        )

class PPDSUndefTargetHeaderFile(PPDSAbstractTargetHeaderFile):

    def write_opening_message(self):

        super().write_opening_message()
        self.f.write(
        """
        /*This file removes definitions as cleanup.*/
        \n
        """
        )

# Top file is always open, can write directly to top
class PPDSTargetFileStack():

    def __init__(self):

        self.ls = []

    def __len__(self):

        return len(self.ls)

    def push(self, file):

        # sanity check
        if not isinstance(file, PPDSAbstractTargetHeaderFile):
            raise ValueError(str(file)+ " is not valid in file-stack")

        # close the previous file
        if not self.is_empty():
            self.ls[-1].close()

        self.ls.append(file)

    def is_empty(self):

        return len(self.ls)==0

    def pop(self):

        ret = self.ls.pop()

        if not self.is_empty():
            self.ls[-1].reopen()

        return ret

    def write_to_top(self, s : str):

        if self.is_empty():
            raise ValueError("Cannot write to empty stack")

        self.ls[-1].write(s)

    def __str__(self):

        return str(self.ls)



class PreprocessorDataClass():

    def __init__(self, name, source_string):

        # TODO: Is it smart to use the file as a string and not file-object?
        # meh, it's easier
        self.name = name
        self.def_template = template_factory.get_def_template_from_source_string(source_string)
        self.undef_template = template_factory.get_undef_template_from_source_string(source_string)
        self.posargs, self.kwargs = template_factory.get_args_from_source_string(source_string)

        #TODO: should allow filepaths
        self.def_rex = re.compile(r'\#include\s+"PPDS_DEF_(\w+)\.h"')
        self.undef_rex = re.compile(r'\#include\s+"PPDS_UNDEF_(\w+)\.h"')

        self.declare_rex = re.compile(rf"\s*PPDS_DECLARE_{self.name}(\(.*)")


    def __str__(self):

        return f"args: {str(self.posargs)}, kwargs: {str(self.kwargs)}, name: {self.name}"

    # TODO: this is a bit incorrect
    def __repr__(self):
        return str(self)

    # TODO this method in particular needs awesome error reporting
    def parse_args(self, argstring):

        
        user_args = parse_args_string(argstring, self.posargs, self.kwargs)

        # initialize with defaults
        argdict = {**self.kwargs}

        argdict.update(user_args)
        
        return argdict


    def handle_code(self, cleaned_c_source, filename):

        defstack = PPDSTargetFileStack()
        undefstack = PPDSTargetFileStack()

        # the important lines are: include def, include undef and declare
        for line_no, line in enumerate(cleaned_c_source.splitlines()):

            try:
                assert(len(defstack)==len(undefstack))

                # is it a definition-target-header?
                m = re.match(self.def_rex, line)
                if m:
                    defstack.push(
                    PPDSDefTargetHeaderFile(f"PPDS_DEF_{m.group(1)}.h")
                    )
                    undefstack.push(
                    PPDSDefTargetHeaderFile(f"PPDS_UNDEF_{m.group(1)}.h")
                    )
                    print("new def header")
                    print(defstack)
                    continue

                m = re.match(self.undef_rex, line)
                if m:
                    def_file = defstack.pop()
                    undef_file = undefstack.pop()
                    md = re.match(r"PPDS_DEF_(\w*)\.h", def_file.filename)
                    mu = re.match(r"PPDS_UNDEF_(\w*)\.h", undef_file.filename)
                    assert(md)
                    assert(mu)
                    assert(mu.group(1) == md.group(1))
                    if mu.group(1) != m.group(1):
                        raise PPDSParseError("closing wrong scope")

                    print("new undef header")
                    print(defstack)
                    continue

                m = re.match(self.declare_rex, line)
                if m:
                    raw_args = m.group(1)
                    argdict = self.parse_args(raw_args)
                    declare_site = f"file: {filename}, line {line_no}"

                    extradef = util.header_from_template(self.def_template, argdict, declare_site=declare_site)
                    extraundef = util.header_from_template(self.undef_template, argdict, declare_site=declare_site)

                    defstack.write_to_top(extradef)
                    undefstack.write_to_top(extraundef)

            except PPDSParseError as e:
                print(
                f"""
ERROR parsing PPDS-annotations in file {filename} line {line_no}:
{line.strip()}
{e.reason}

{e.detail}
                """)
                exit(1)

        assert(len(defstack)==len(undefstack))
        if len(defstack) > 0:
            # this should not be a valueerror but a proper message
            raise ValueError(f"unclosed definition-headers: {defstack}")



# proper argparsing later
files = sys.argv[1:]
print("doing files: ", files)
ppds_source_header_dir = "ppds_source_headers"
ppds_target_header_dir = "ppds_target_headers"

for filename in files:

    with open(filename, "r") as f:
        # preserves line numbers
        code = util.remove_comments(f.read())

    source_names = re.findall(SOURCE_REX, code)
    source_strings = []
    pp_dataclasses = []
    for name in source_names:
        try:
            source_filename = f"PPDS_SOURCE_{name}.h"
            with open(os.path.join(ppds_source_header_dir, source_filename)) as f:
                source_string = f.read()
            source_strings.append(source_string)
            pp_dataclasses.append(PreprocessorDataClass(name, source_string))
        except PPDSParseError as e:
            print(
                f"""
ERROR related to file {source_filename} :

{e.reason}

{e.detail}
                """)
            exit(1)



    for ppc in pp_dataclasses:
        ppc.handle_code(code, filename)
    print(pp_dataclasses)
